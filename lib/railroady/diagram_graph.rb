# RailRoady - RoR diagrams generator
# http://railroad.rubyforge.org
#
# Copyright 2007-2008 - Javier Smaldone (http://www.smaldone.com.ar)
# See COPYING for more details


# RailRoady diagram structure
class DiagramGraph

  attr_writer :label
  attr_accessor :github, :groups
  APP_MODEL_GIT_PATH = "blob/master/app/models/"

  def initialize
    @diagram_type = ''
    @show_label = false
    @model_nodes = []
    @sti_clusters = {}
  end

  def add_model_node(model_node)
    @model_nodes << model_node
  end

  def diagram_type= (type)
    @diagram_type = type
  end

  def show_label= (value)
    @show_label = value
  end

  def label
    @label ||= [
      "#{@diagram_type} diagram",
      "Date: #{Time.now.strftime "%b %d %Y - %H:%M"}" +
      "Migration version: #{ActiveRecord::Migrator.current_version}" +
      "Generated by #{APP_HUMAN_NAME} #{APP_VERSION}"+
      "http://railroady.prestonlee.com" ]
  end

  def to_dot
    create_sti_clusters!
    dot_diagram do
      dot_groups(@groups) +
      @sti_clusters.map{ |superclass_name, model_nodes| dot_sti_cluster(superclass_name, model_nodes) }.join +
      @model_nodes.map{ |model_node| dot_node(model_node) unless @sti_clusters.has_value?(model_node) || @groups.flatten.include?(model_node) }.join +
      @model_nodes.map{ |model_node| model_node.edges.map { |edge| dot_edge(edge) } }.join
    end
  end

  # Generate XMI diagram (not yet implemented)
  def to_xmi
     STDERR.print "Sorry. XMI output not yet implemented.\n\n"
     return ""
  end

  private

  def create_sti_clusters!
    @sti_clusters = @model_nodes.select { |model_node| model_node.sti_inheritance }.each_with_object({}) do |model_node, h|
      superclass_name = model_node.superclass_name[/^(\w+)|::/]
      h.has_key?(superclass_name) ? h[superclass_name] << model_node : h[superclass_name] = [model_node]
    end.each do |superclass_name, model_nodes|
      superclass_model_node = @model_nodes.select { |model_node| model_node == superclass_name }.first
      model_nodes.unshift(superclass_model_node)
    end
  end

  def dot_groups(groups)
    return "" if groups.nil? || groups.empty?
    
    dot_subgraph("overview", :visible => false) do
      groups_with_model_nodes!.map do |model_node_group|
        dot_subgraph(model_node_group.first.class_name, :visible => false) do
          model_node_group.map do |model_node|
            @sti_clusters.has_key?(model_node.class_name) ? dot_sti_cluster(model_node.class_name, @sti_clusters.delete(model_node.class_name)) :
              dot_node(model_node)
          end.join
        end
      end.join
    end
  end

  # Reformat the groups' model name and extrapolate the wildcards
  def expand_group_name(model_name)
    model_name.camelize.match(/\w+\*/).nil? ? [model_name.camelize] :
      @model_nodes.select { |model_node| !model_node.class_name.match(/^#{model_name.camelize[0..-2]}.*$/).nil? }.map { |model_node| model_node.class_name.camelize }.flatten
  end

  def groups_with_model_nodes!
    @groups.map! do |group|
      group.map! do |model_name|
        expand_group_name(model_name).map do |result|
          @model_nodes.select { |model_node| model_node == result }.first
        end
      end.flatten
    end
    sort_groups_by_edge_sum(@groups)
  end

  # Sorts each grouping by its sum in ascending order
  def sort_groups_by_edge_sum(groups)
    groups.each_with_object({}) do |group, h|
      h[sort_model_nodes_by_edge_count(group)] = group_edge_sum(group)
    end.sort { |a,b|  a[1] <=> b[1] }.map { |arr| arr[0] }
  end

  # Sorts each model name within a grouping by its sum of edges in descending order
  def sort_model_nodes_by_edge_count(group)
    group.sort do |model_node_a, model_node_b|
      model_node_b.edges.size <=> model_node_a.edges.size
    end
  end

  def group_edge_sum(group)
    group.map { |model_name| model_name.edges.size }.inject(&:+)
  end

  def dot_sti_cluster(superclass_name, model_nodes)
    dot_subgraph(superclass_name) do
      model_nodes.map { |model_node| dot_node(model_node) }.join +
      dot_sti_cluster_edge(superclass_name, model_nodes)
    end
  end

  def dot_sti_cluster_edge(superclass_name, model_nodes)
    aggregate_edge = "#{superclass_name}_edge"

    %{\t"#{aggregate_edge}"[label="", fixedsize="false", width=0, height=0, shape=none]\n} +
    %{\t\t#{quote(superclass_name)} -> "#{aggregate_edge}"[label="", dir="back", arrowtail=empty, arrowsize="2", len="0.2"]\n} +
      
    model_nodes[1..-1].map do |model_node| # Skipping parent node with superclass being Object or ActiveRecord::Base
      type, class_name = model_node.superclass_name==superclass_name ? ['is-a', aggregate_edge] : ['is-a-child', model_node.superclass_name]
      dot_edge(type, class_name, model_node.class_name)
    end.join("\t")
  end

  def dot_node(model_node)
    case model_node.type
      when 'model'
           options = 'shape=Mrecord, label="{' + model_node.class_name + '|'
           options += model_node.attributes.join('\l')
           options += '\l}"'
           if filepath = github_file_url(model_node.class_name)
             options += ", URL=#{quote(filepath)}"
           end
      when 'model-brief'
           options = ''
      when 'class'
           options = 'shape=record, label="{' + model_node.class_name + '|}"'
      when 'class-brief'
           options = 'shape=box'
      when 'controller'
           options = 'shape=Mrecord, label="{' + name + '|'
           public_methods    = model_node.attributes[:public].join('\l')
           protected_methods = model_node.attributes[:protected].join('\l')
           private_methods   = model_node.attributes[:private].join('\l')
           options += public_methods + '\l|' + protected_methods + '\l|' +
                      private_methods + '\l'
           options += '}"'
      when 'controller-brief'
           options = ''
      when 'module'
           options = 'shape=box, style=dotted, label="' + model_node.class_name + '"'
      when 'aasm'
           # Return subgraph format
           return "subgraph cluster_#{model_node.class_name.downcase} {\n\tlabel = #{quote(model_node.class_name)}\n\t#{model_node.attributes.join("\n  ")}}"
    end
    return "\t#{quote(model_node.class_name)} [#{options}]\n"
  end

  # Reference: http://www.graphviz.org/doc/info/attrs.html
  def dot_edge(*args)
    type, from, to, name = if args[0].is_a?(ModelEdge)
      model_edge = args[0]
      [model_edge.type, model_edge.from_class_name, model_edge.to_class_name, (model_edge.association_type || '')]
    else
      [*args, '']
    end
    
    options =  name != '' ? "label=\"#{name}\", tooltip=\"#{name}\", " : ''
    options +=  case type
      when 'one-one'    then 'arrowtail=tee,  arrowhead=odot, dir="both"'
      when 'one-many'   then 'arrowtail=odot, arrowhead=crow, dir="both"'
      when 'many-many'  then 'arrowtail=crow, arrowhead=crow, dir="both"'
      when 'is-a'       then 'label="", dir="none"'
      when 'is-a-child' then 'label="", dir="back", arrowtail=empty'
      when 'invisible'  then 'style=invis, dir=both'
      when 'event'      then "fontsize=10"
      else raise("Unknown type: #{type}")
    end

    "\t#{quote(from)} -> #{quote(to)} [#{options}]\n"
  end

  def dot_subgraph(label, options=nil)
    %{#{dot_cluster_header(label, options)} \n\t\t#{yield} \n\t\t#{dot_footer}}
  end

  def dot_cluster_header(name, options=nil)
    label, color = (!options.nil? && !options[:visible]) ? ["","#FFFFFF"] : [name, "#000000"]
    string = "\tsubgraph cluster_#{name.underscore} {\n\t\tlabel=#{quote(label)};\n"
    string + "\t\tcolor=#{quote(color)};\n"
  end

  def dot_label
    return if !@show_label || label.empty?
    "\tlabelloc=\"t\";\n \tlabel=\"#{label.map {|x| "#{x}\\l" }.join}\"\n"
  end

  def dot_diagram
    %{#{dot_header} \n\t\t#{yield} \n\t\t#{dot_footer}}
  end

  def dot_header
    "digraph #{@diagram_type.downcase}_diagram {\n\tgraph[overlap=false, outputorder=edgesfirst, splines=ortho] \n\tnode[style=filled, fillcolor=white]\n#{dot_label}"
  end

  def dot_footer
    "}\n"
  end

  def github_file_url(class_name)
    filename = class_name.underscore
    last = nil
    possible_paths = filename.split("/").map do |piece|
      last = [last, piece].join("/")
    end
    path = possible_paths.detect do |path|
      File.exists?("#{Rails.root}/app/models#{path}.rb")
    end
    path ||= filename
    @github + APP_MODEL_GIT_PATH + path[1..-1] + '.rb' if !@github.nil?
  end

  def quote(name)
    %{"#{name}"}
  end
end
